// Package dbnav provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package dbnav

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
)

// Defines values for FeatureType.
const (
	FeatureTypeFeature FeatureType = "Feature"
)

// Defines values for FeatureCollectionType.
const (
	FeatureCollectionTypeFeatureCollection FeatureCollectionType = "FeatureCollection"
)

// Defines values for GeometryType.
const (
	Point GeometryType = "Point"
)

// Defines values for HintType.
const (
	HintTypeForeignId        HintType = "foreign-id"
	HintTypeHint             HintType = "hint"
	HintTypeLocalFareZone    HintType = "local-fare-zone"
	HintTypeStatus           HintType = "status"
	HintTypeStopDhid         HintType = "stop-dhid"
	HintTypeStopWebsite      HintType = "stop-website"
	HintTypeTransitAuthority HintType = "transit-authority"
)

// Defines values for JourneyType.
const (
	JourneyTypeJourney JourneyType = "journey"
)

// Defines values for LineMode.
const (
	Aircraft   LineMode = "aircraft"
	Bicycle    LineMode = "bicycle"
	Bus        LineMode = "bus"
	Car        LineMode = "car"
	Gondola    LineMode = "gondola"
	Taxi       LineMode = "taxi"
	Train      LineMode = "train"
	Walking    LineMode = "walking"
	Watercraft LineMode = "watercraft"
)

// Defines values for LineType.
const (
	LineTypeLine LineType = "line"
)

// Defines values for LocationType.
const (
	LocationTypeLocation LocationType = "location"
)

// Defines values for OperatorType.
const (
	OperatorTypeOperator OperatorType = "operator"
)

// Defines values for PrognosisType.
const (
	Calculated PrognosisType = "calculated"
	Prognosed  PrognosisType = "prognosed"
)

// Defines values for StationType.
const (
	StationTypeStation StationType = "station"
)

// Defines values for StatusType.
const (
	StatusTypeForeignId        StatusType = "foreign-id"
	StatusTypeHint             StatusType = "hint"
	StatusTypeLocalFareZone    StatusType = "local-fare-zone"
	StatusTypeStatus           StatusType = "status"
	StatusTypeStopDhid         StatusType = "stop-dhid"
	StatusTypeStopWebsite      StatusType = "stop-website"
	StatusTypeTransitAuthority StatusType = "transit-authority"
)

// Defines values for StopType.
const (
	StopTypeStop StopType = "stop"
)

// Defines values for WarningType.
const (
	WarningTypeStatus  WarningType = "status"
	WarningTypeWarning WarningType = "warning"
)

// Defines values for GetJourneysParamsWalkingSpeed.
const (
	Fast   GetJourneysParamsWalkingSpeed = "fast"
	Normal GetJourneysParamsWalkingSpeed = "normal"
	Slow   GetJourneysParamsWalkingSpeed = "slow"
)

// Defines values for GetJourneysParamsLoyaltyCard.
const (
	AtKlimaticket        GetJourneysParamsLoyaltyCard = "at-klimaticket"
	Bahncard1st100       GetJourneysParamsLoyaltyCard = "bahncard-1st-100"
	Bahncard1st25        GetJourneysParamsLoyaltyCard = "bahncard-1st-25"
	Bahncard1st50        GetJourneysParamsLoyaltyCard = "bahncard-1st-50"
	Bahncard2nd100       GetJourneysParamsLoyaltyCard = "bahncard-2nd-100"
	Bahncard2nd25        GetJourneysParamsLoyaltyCard = "bahncard-2nd-25"
	Bahncard2nd50        GetJourneysParamsLoyaltyCard = "bahncard-2nd-50"
	Generalabonnement1st GetJourneysParamsLoyaltyCard = "generalabonnement-1st"
	Generalabonnement2nd GetJourneysParamsLoyaltyCard = "generalabonnement-2nd"
	Halbtaxabo           GetJourneysParamsLoyaltyCard = "halbtaxabo"
	Nl40                 GetJourneysParamsLoyaltyCard = "nl-40"
	Vorteilscard         GetJourneysParamsLoyaltyCard = "vorteilscard"
)

// Alternative defines model for Alternative.
type Alternative struct {
	Cancelled *bool `json:"cancelled,omitempty"`

	// CurrentTripPosition A location object is used by other items to indicate their locations.
	CurrentTripPosition *Location                `json:"currentTripPosition,omitempty"`
	Delay               *float32                 `json:"delay,omitempty"`
	Destination         *Alternative_Destination `json:"destination,omitempty"`
	Direction           *string                  `json:"direction,omitempty"`
	Frames              *[]Frame                 `json:"frames,omitempty"`
	Line                *Line                    `json:"line,omitempty"`
	LoadFactor          *string                  `json:"loadFactor,omitempty"`

	// Location A location object is used by other items to indicate their locations.
	Location          *Location                   `json:"location,omitempty"`
	NextStopovers     *[]StopOver                 `json:"nextStopovers,omitempty"`
	Origin            *Alternative_Origin         `json:"origin,omitempty"`
	PlannedPlatform   *string                     `json:"plannedPlatform,omitempty"`
	PlannedWhen       *string                     `json:"plannedWhen,omitempty"`
	Platform          *string                     `json:"platform,omitempty"`
	Polyline          *FeatureCollection          `json:"polyline,omitempty"`
	PreviousStopovers *[]StopOver                 `json:"previousStopovers,omitempty"`
	PrognosedPlatform *string                     `json:"prognosedPlatform,omitempty"`
	PrognosedWhen     *string                     `json:"prognosedWhen,omitempty"`
	PrognosisType     *PrognosisType              `json:"prognosisType,omitempty"`
	Provenance        *string                     `json:"provenance,omitempty"`
	Remarks           *[]Alternative_Remarks_Item `json:"remarks,omitempty"`
	Stop              *Alternative_Stop           `json:"stop,omitempty"`
	TripId            *string                     `json:"tripId,omitempty"`
	When              *string                     `json:"when,omitempty"`
}

// Alternative_Destination defines model for Alternative.Destination.
type Alternative_Destination struct {
	union json.RawMessage
}

// Alternative_Origin defines model for Alternative.Origin.
type Alternative_Origin struct {
	union json.RawMessage
}

// Alternative_Remarks_Item defines model for Alternative.remarks.Item.
type Alternative_Remarks_Item struct {
	union json.RawMessage
}

// Alternative_Stop defines model for Alternative.Stop.
type Alternative_Stop struct {
	union json.RawMessage
}

// Cycle defines model for Cycle.
type Cycle struct {
	Max *float32 `json:"max,omitempty"`
	Min *float32 `json:"min,omitempty"`
	Nr  *float32 `json:"nr,omitempty"`
}

// Edge defines model for Edge.
type Edge struct {
	Dir          *float32                `json:"dir,omitempty"`
	FromLocation *Edge_FromLocation      `json:"fromLocation,omitempty"`
	IcoCrd       *IcoCrd                 `json:"icoCrd,omitempty"`
	Icon         *map[string]interface{} `json:"icon,omitempty"`
	ToLocation   *Edge_ToLocation        `json:"toLocation,omitempty"`
}

// Edge_FromLocation defines model for Edge.FromLocation.
type Edge_FromLocation struct {
	union json.RawMessage
}

// Edge_ToLocation defines model for Edge.ToLocation.
type Edge_ToLocation struct {
	union json.RawMessage
}

// Event defines model for Event.
type Event struct {
	End          *string             `json:"end,omitempty"`
	FromLocation *Event_FromLocation `json:"fromLocation,omitempty"`
	Sections     *[]string           `json:"sections,omitempty"`
	Start        *string             `json:"start,omitempty"`
	ToLocation   *Event_ToLocation   `json:"toLocation,omitempty"`
}

// Event_FromLocation defines model for Event.FromLocation.
type Event_FromLocation struct {
	union json.RawMessage
}

// Event_ToLocation defines model for Event.ToLocation.
type Event_ToLocation struct {
	union json.RawMessage
}

// Facilities defines model for Facilities.
type Facilities map[string]string

// Feature defines model for Feature.
type Feature struct {
	Geometry   *Geometry           `json:"geometry,omitempty"`
	Properties *Feature_Properties `json:"properties,omitempty"`
	Type       *FeatureType        `json:"type,omitempty"`
}

// FeatureProperties0 defines model for .
type FeatureProperties0 map[string]interface{}

// Feature_Properties defines model for Feature.Properties.
type Feature_Properties struct {
	union json.RawMessage
}

// FeatureType defines model for Feature.Type.
type FeatureType string

// FeatureCollection defines model for FeatureCollection.
type FeatureCollection struct {
	Features *[]Feature             `json:"features,omitempty"`
	Type     *FeatureCollectionType `json:"type,omitempty"`
}

// FeatureCollectionType defines model for FeatureCollection.Type.
type FeatureCollectionType string

// Frame defines model for Frame.
type Frame struct {
	Destination *Frame_Destination `json:"destination,omitempty"`
	Origin      *Frame_Origin      `json:"origin,omitempty"`
	T           *float32           `json:"t,omitempty"`
}

// Frame_Destination defines model for Frame.Destination.
type Frame_Destination struct {
	union json.RawMessage
}

// Frame_Origin defines model for Frame.Origin.
type Frame_Origin struct {
	union json.RawMessage
}

// Geometry defines model for Geometry.
type Geometry struct {
	Coordinates *[]float32    `json:"coordinates,omitempty"`
	Type        *GeometryType `json:"type,omitempty"`
}

// GeometryType defines model for Geometry.Type.
type GeometryType string

// Hint defines model for Hint.
type Hint struct {
	Code    *string   `json:"code,omitempty"`
	Summary *string   `json:"summary,omitempty"`
	Text    *string   `json:"text,omitempty"`
	TripId  *string   `json:"tripId,omitempty"`
	Type    *HintType `json:"type,omitempty"`
}

// HintType defines model for Hint.Type.
type HintType string

// IcoCrd defines model for IcoCrd.
type IcoCrd struct {
	Type *string  `json:"type,omitempty"`
	X    *float32 `json:"x,omitempty"`
	Y    *float32 `json:"y,omitempty"`
}

// Ids Ids of a Stop, i.e. dhid as 'DELFI Haltestellen ID'
type Ids map[string]string

// Journey A journey is a computed set of directions to get from A to B at a specific time.
// It would typically be the result of a route planning algorithm.
type Journey struct {
	Cycle         *Cycle                  `json:"cycle,omitempty"`
	Legs          *[]Leg                  `json:"legs,omitempty"`
	Price         *Price                  `json:"price,omitempty"`
	RefreshToken  *string                 `json:"refreshToken,omitempty"`
	Remarks       *[]Journey_Remarks_Item `json:"remarks,omitempty"`
	ScheduledDays *ScheduledDays          `json:"scheduledDays,omitempty"`
	Type          *JourneyType            `json:"type,omitempty"`
}

// Journey_Remarks_Item defines model for Journey.remarks.Item.
type Journey_Remarks_Item struct {
	union json.RawMessage
}

// JourneyType defines model for Journey.Type.
type JourneyType string

// Leg Leg of journey
type Leg struct {
	Alternatives         *[]Alternative `json:"alternatives,omitempty"`
	Arrival              *string        `json:"arrival,omitempty"`
	ArrivalDelay         *float32       `json:"arrivalDelay,omitempty"`
	ArrivalPlatform      *string        `json:"arrivalPlatform,omitempty"`
	ArrivalPrognosisType *PrognosisType `json:"arrivalPrognosisType,omitempty"`
	Cancelled            *bool          `json:"cancelled,omitempty"`
	Checkin              *bool          `json:"checkin,omitempty"`

	// CurrentLocation A location object is used by other items to indicate their locations.
	CurrentLocation            *Location           `json:"currentLocation,omitempty"`
	Cycle                      *Cycle              `json:"cycle,omitempty"`
	Departure                  *string             `json:"departure,omitempty"`
	DepartureDelay             *float32            `json:"departureDelay,omitempty"`
	DeparturePlatform          *string             `json:"departurePlatform,omitempty"`
	DeparturePrognosisType     *PrognosisType      `json:"departurePrognosisType,omitempty"`
	Destination                *Leg_Destination    `json:"destination,omitempty"`
	Direction                  *string             `json:"direction,omitempty"`
	Distance                   *float32            `json:"distance,omitempty"`
	Line                       *Line               `json:"line,omitempty"`
	LoadFactor                 *string             `json:"loadFactor,omitempty"`
	Operator                   *float32            `json:"operator,omitempty"`
	Origin                     *Leg_Origin         `json:"origin,omitempty"`
	PlannedArrival             *string             `json:"plannedArrival,omitempty"`
	PlannedArrivalPlatform     *string             `json:"plannedArrivalPlatform,omitempty"`
	PlannedDeparture           *string             `json:"plannedDeparture,omitempty"`
	PlannedDeparturePlatform   *string             `json:"plannedDeparturePlatform,omitempty"`
	Polyline                   *FeatureCollection  `json:"polyline,omitempty"`
	Price                      *Price              `json:"price,omitempty"`
	PrognosedArrival           *string             `json:"prognosedArrival,omitempty"`
	PrognosedArrivalPlatform   *string             `json:"prognosedArrivalPlatform,omitempty"`
	PrognosedDeparture         *string             `json:"prognosedDeparture,omitempty"`
	PrognosedDeparturePlatform *string             `json:"prognosedDeparturePlatform,omitempty"`
	Public                     *bool               `json:"public,omitempty"`
	Reachable                  *bool               `json:"reachable,omitempty"`
	Remarks                    *[]Leg_Remarks_Item `json:"remarks,omitempty"`
	Schedule                   *float32            `json:"schedule,omitempty"`
	Stopovers                  *[]StopOver         `json:"stopovers,omitempty"`
	Transfer                   *bool               `json:"transfer,omitempty"`
	TripId                     *string             `json:"tripId,omitempty"`
	Walking                    *bool               `json:"walking,omitempty"`
}

// Leg_Destination defines model for Leg.Destination.
type Leg_Destination struct {
	union json.RawMessage
}

// Leg_Origin defines model for Leg.Origin.
type Leg_Origin struct {
	union json.RawMessage
}

// Leg_Remarks_Item defines model for Leg.remarks.Item.
type Leg_Remarks_Item struct {
	union json.RawMessage
}

// Line defines model for Line.
type Line struct {
	AdditionalName *string   `json:"additionalName,omitempty"`
	AdminCode      *string   `json:"adminCode,omitempty"`
	Directions     *[]string `json:"directions,omitempty"`
	Express        *bool     `json:"express,omitempty"`
	FahrtNr        *string   `json:"fahrtNr,omitempty"`
	Id             *string   `json:"id,omitempty"`
	Metro          *bool     `json:"metro,omitempty"`
	Mode           *LineMode `json:"mode,omitempty"`
	Name           *string   `json:"name,omitempty"`
	Night          *bool     `json:"night,omitempty"`
	Nr             *float32  `json:"nr,omitempty"`
	Operator       *Operator `json:"operator,omitempty"`
	Product        *string   `json:"product,omitempty"`
	ProductName    *string   `json:"productName,omitempty"`
	Public         *bool     `json:"public,omitempty"`

	// Routes routes ids
	Routes *[]string `json:"routes,omitempty"`
	Symbol *string   `json:"symbol,omitempty"`
	Type   *LineType `json:"type,omitempty"`
}

// LineMode defines model for Line.Mode.
type LineMode string

// LineType defines model for Line.Type.
type LineType string

// Location A location object is used by other items to indicate their locations.
type Location struct {
	Address   *string       `json:"address,omitempty"`
	Altitude  *float32      `json:"altitude,omitempty"`
	Distance  *float32      `json:"distance,omitempty"`
	Id        *string       `json:"id,omitempty"`
	Latitude  *float32      `json:"latitude,omitempty"`
	Longitude *float32      `json:"longitude,omitempty"`
	Name      *string       `json:"name,omitempty"`
	Poi       *bool         `json:"poi,omitempty"`
	Type      *LocationType `json:"type,omitempty"`
}

// LocationType defines model for Location.Type.
type LocationType string

// Operator defines model for Operator.
type Operator struct {
	Id   *string       `json:"id,omitempty"`
	Name *string       `json:"name,omitempty"`
	Type *OperatorType `json:"type,omitempty"`
}

// OperatorType defines model for Operator.Type.
type OperatorType string

// Price defines model for Price.
type Price struct {
	Amount   *float32 `json:"amount,omitempty"`
	Currency *string  `json:"currency,omitempty"`
	Hint     *string  `json:"hint,omitempty"`
}

// Products Each public transportation network exposes its products as boolean properties. See {@link ProductType}
type Products map[string]bool

// ProfileSpecificProducts defines model for ProfileSpecificProducts.
type ProfileSpecificProducts struct {
	// Bus Include Bus (B)?
	Bus *bool `json:"bus,omitempty"`

	// Ferry Include Ferry (F)?
	Ferry *bool `json:"ferry,omitempty"`

	// National Include InterCity & EuroCity (IC/EC)?
	National *bool `json:"national,omitempty"`

	// NationalExpress Include InterCityExpress (ICE)?
	NationalExpress *bool `json:"nationalExpress,omitempty"`

	// Regional Include Regio (RB)?
	Regional *bool `json:"regional,omitempty"`

	// RegionalExpress Include InterRegio, FlixTrain, Westbahn etc.?
	RegionalExpress *bool `json:"regionalExpress,omitempty"`

	// Suburban Include S-Bahn (S)?
	Suburban *bool `json:"suburban,omitempty"`

	// Subway Include U-Bahn (U)?
	Subway *bool `json:"subway,omitempty"`

	// Taxi Include Group Taxi (Taxi)?
	Taxi *bool `json:"taxi,omitempty"`

	// Tram Include Tram (T)?
	Tram *bool `json:"tram,omitempty"`
}

// PrognosisType defines model for PrognosisType.
type PrognosisType string

// ReisezentrumOpeningHours defines model for ReisezentrumOpeningHours.
type ReisezentrumOpeningHours struct {
	Di *string `json:"Di,omitempty"`
	Do *string `json:"Do,omitempty"`
	Fr *string `json:"Fr,omitempty"`
	Mi *string `json:"Mi,omitempty"`
	Mo *string `json:"Mo,omitempty"`
	Sa *string `json:"Sa,omitempty"`
	So *string `json:"So,omitempty"`
}

// ScheduledDays defines model for ScheduledDays.
type ScheduledDays map[string]bool

// Station A station is a larger building or area that can be identified by a name.
// It is usually represented by a single node on a public transport map.
// Whereas a stop usually specifies a location, a station often is a broader area
// that may span across multiple levels or buildings.
type Station struct {
	Distance   *float32    `json:"distance,omitempty"`
	Entrances  *[]Location `json:"entrances,omitempty"`
	Facilities *Facilities `json:"facilities,omitempty"`
	Id         *string     `json:"id,omitempty"`
	IsMeta     *bool       `json:"isMeta,omitempty"`
	Lines      *[]Line     `json:"lines,omitempty"`

	// Location A location object is used by other items to indicate their locations.
	Location *Location `json:"location,omitempty"`
	Name     *string   `json:"name,omitempty"`

	// Products Each public transportation network exposes its products as boolean properties. See {@link ProductType}
	Products *Products `json:"products,omitempty"`

	// Regions region ids
	Regions                  *[]string                 `json:"regions,omitempty"`
	ReisezentrumOpeningHours *ReisezentrumOpeningHours `json:"reisezentrumOpeningHours,omitempty"`

	// Station A station is a larger building or area that can be identified by a name.
	// It is usually represented by a single node on a public transport map.
	// Whereas a stop usually specifies a location, a station often is a broader area
	// that may span across multiple levels or buildings.
	Station          *Station              `json:"station,omitempty"`
	Stops            *[]Station_Stops_Item `json:"stops,omitempty"`
	TransitAuthority *string               `json:"transitAuthority,omitempty"`
	Type             *StationType          `json:"type,omitempty"`
}

// Station_Stops_Item defines model for Station.stops.Item.
type Station_Stops_Item struct {
	union json.RawMessage
}

// StationType defines model for Station.Type.
type StationType string

// Status defines model for Status.
type Status struct {
	Code    *string     `json:"code,omitempty"`
	Summary *string     `json:"summary,omitempty"`
	Text    *string     `json:"text,omitempty"`
	TripId  *string     `json:"tripId,omitempty"`
	Type    *StatusType `json:"type,omitempty"`
}

// StatusType defines model for Status.Type.
type StatusType string

// Stop A stop is a single small point or structure at which vehicles stop.
// A stop always belongs to a station. It may for example be a sign, a basic shelter or a railway platform.
type Stop struct {
	Distance  *float32    `json:"distance,omitempty"`
	Entrances *[]Location `json:"entrances,omitempty"`
	Id        *string     `json:"id,omitempty"`

	// Ids Ids of a Stop, i.e. dhid as 'DELFI Haltestellen ID'
	Ids        *Ids    `json:"ids,omitempty"`
	IsMeta     *bool   `json:"isMeta,omitempty"`
	Lines      *[]Line `json:"lines,omitempty"`
	LoadFactor *string `json:"loadFactor,omitempty"`

	// Location A location object is used by other items to indicate their locations.
	Location *Location `json:"location,omitempty"`
	Name     *string   `json:"name,omitempty"`

	// Products Each public transportation network exposes its products as boolean properties. See {@link ProductType}
	Products                 *Products                 `json:"products,omitempty"`
	ReisezentrumOpeningHours *ReisezentrumOpeningHours `json:"reisezentrumOpeningHours,omitempty"`

	// Station A station is a larger building or area that can be identified by a name.
	// It is usually represented by a single node on a public transport map.
	// Whereas a stop usually specifies a location, a station often is a broader area
	// that may span across multiple levels or buildings.
	Station          *Station  `json:"station,omitempty"`
	TransitAuthority *string   `json:"transitAuthority,omitempty"`
	Type             *StopType `json:"type,omitempty"`
}

// StopType defines model for Stop.Type.
type StopType string

// StopOver A stopover represents a vehicle stopping at a stop/station at a specific time.
type StopOver struct {
	Additional *bool `json:"additional,omitempty"`

	// Arrival null, if first stopOver of trip
	Arrival              *string        `json:"arrival,omitempty"`
	ArrivalDelay         *float32       `json:"arrivalDelay,omitempty"`
	ArrivalPlatform      *string        `json:"arrivalPlatform,omitempty"`
	ArrivalPrognosisType *PrognosisType `json:"arrivalPrognosisType,omitempty"`
	Cancelled            *bool          `json:"cancelled,omitempty"`

	// Departure null, if last stopOver of trip
	Departure                  *string                  `json:"departure,omitempty"`
	DepartureDelay             *float32                 `json:"departureDelay,omitempty"`
	DeparturePlatform          *string                  `json:"departurePlatform,omitempty"`
	DeparturePrognosisType     *PrognosisType           `json:"departurePrognosisType,omitempty"`
	PassBy                     *bool                    `json:"passBy,omitempty"`
	PlannedArrival             *string                  `json:"plannedArrival,omitempty"`
	PlannedArrivalPlatform     *string                  `json:"plannedArrivalPlatform,omitempty"`
	PlannedDeparture           *string                  `json:"plannedDeparture,omitempty"`
	PlannedDeparturePlatform   *string                  `json:"plannedDeparturePlatform,omitempty"`
	PrognosedArrival           *string                  `json:"prognosedArrival,omitempty"`
	PrognosedArrivalPlatform   *string                  `json:"prognosedArrivalPlatform,omitempty"`
	PrognosedDeparture         *string                  `json:"prognosedDeparture,omitempty"`
	PrognosedDeparturePlatform *string                  `json:"prognosedDeparturePlatform,omitempty"`
	Remarks                    *[]StopOver_Remarks_Item `json:"remarks,omitempty"`
	Stop                       *StopOver_Stop           `json:"stop,omitempty"`
}

// StopOver_Remarks_Item defines model for StopOver.remarks.Item.
type StopOver_Remarks_Item struct {
	union json.RawMessage
}

// StopOver_Stop defines model for StopOver.Stop.
type StopOver_Stop struct {
	union json.RawMessage
}

// Trip Trip – a vehicle stopping at a set of stops at specific times
type Trip struct {
	Alternatives         *[]Alternative `json:"alternatives,omitempty"`
	Arrival              *string        `json:"arrival,omitempty"`
	ArrivalDelay         *float32       `json:"arrivalDelay,omitempty"`
	ArrivalPlatform      *string        `json:"arrivalPlatform,omitempty"`
	ArrivalPrognosisType *PrognosisType `json:"arrivalPrognosisType,omitempty"`
	Cancelled            *bool          `json:"cancelled,omitempty"`
	Checkin              *bool          `json:"checkin,omitempty"`

	// CurrentLocation A location object is used by other items to indicate their locations.
	CurrentLocation            *Location            `json:"currentLocation,omitempty"`
	Cycle                      *Cycle               `json:"cycle,omitempty"`
	Departure                  *string              `json:"departure,omitempty"`
	DepartureDelay             *float32             `json:"departureDelay,omitempty"`
	DeparturePlatform          *string              `json:"departurePlatform,omitempty"`
	DeparturePrognosisType     *PrognosisType       `json:"departurePrognosisType,omitempty"`
	Destination                *Trip_Destination    `json:"destination,omitempty"`
	Direction                  *string              `json:"direction,omitempty"`
	Distance                   *float32             `json:"distance,omitempty"`
	Id                         *string              `json:"id,omitempty"`
	Line                       *Line                `json:"line,omitempty"`
	LoadFactor                 *string              `json:"loadFactor,omitempty"`
	Operator                   *float32             `json:"operator,omitempty"`
	Origin                     *Trip_Origin         `json:"origin,omitempty"`
	PlannedArrival             *string              `json:"plannedArrival,omitempty"`
	PlannedArrivalPlatform     *string              `json:"plannedArrivalPlatform,omitempty"`
	PlannedDeparture           *string              `json:"plannedDeparture,omitempty"`
	PlannedDeparturePlatform   *string              `json:"plannedDeparturePlatform,omitempty"`
	Polyline                   *FeatureCollection   `json:"polyline,omitempty"`
	Price                      *Price               `json:"price,omitempty"`
	PrognosedArrival           *string              `json:"prognosedArrival,omitempty"`
	PrognosedArrivalPlatform   *string              `json:"prognosedArrivalPlatform,omitempty"`
	PrognosedDeparture         *string              `json:"prognosedDeparture,omitempty"`
	PrognosedDeparturePlatform *string              `json:"prognosedDeparturePlatform,omitempty"`
	Public                     *bool                `json:"public,omitempty"`
	Remarks                    *[]Trip_Remarks_Item `json:"remarks,omitempty"`
	Schedule                   *float32             `json:"schedule,omitempty"`
	ScheduledDays              *ScheduledDays       `json:"scheduledDays,omitempty"`
	Stopovers                  *[]StopOver          `json:"stopovers,omitempty"`
	Transfer                   *bool                `json:"transfer,omitempty"`
	Walking                    *bool                `json:"walking,omitempty"`
}

// Trip_Destination defines model for Trip.Destination.
type Trip_Destination struct {
	union json.RawMessage
}

// Trip_Origin defines model for Trip.Origin.
type Trip_Origin struct {
	union json.RawMessage
}

// Trip_Remarks_Item defines model for Trip.remarks.Item.
type Trip_Remarks_Item struct {
	union json.RawMessage
}

// Warning defines model for Warning.
type Warning struct {
	AffectedLines *[]Line                   `json:"affectedLines,omitempty"`
	Categories    *[]float32                `json:"categories,omitempty"`
	Category      *string                   `json:"category,omitempty"`
	Company       *string                   `json:"company,omitempty"`
	Edges         *[]Edge                   `json:"edges,omitempty"`
	Events        *[]Event                  `json:"events,omitempty"`
	FromStops     *[]Warning_FromStops_Item `json:"fromStops,omitempty"`
	Icon          *map[string]interface{}   `json:"icon,omitempty"`
	Id            *string                   `json:"id,omitempty"`
	Modified      *string                   `json:"modified,omitempty"`
	Priority      *float32                  `json:"priority,omitempty"`

	// Products Each public transportation network exposes its products as boolean properties. See {@link ProductType}
	Products   *Products               `json:"products,omitempty"`
	Summary    *string                 `json:"summary,omitempty"`
	Text       *string                 `json:"text,omitempty"`
	ToStops    *[]Warning_ToStops_Item `json:"toStops,omitempty"`
	Type       *WarningType            `json:"type,omitempty"`
	ValidFrom  *string                 `json:"validFrom,omitempty"`
	ValidUntil *string                 `json:"validUntil,omitempty"`
}

// Warning_FromStops_Item defines model for Warning.fromStops.Item.
type Warning_FromStops_Item struct {
	union json.RawMessage
}

// Warning_ToStops_Item defines model for Warning.toStops.Item.
type Warning_ToStops_Item struct {
	union json.RawMessage
}

// WarningType defines model for Warning.Type.
type WarningType string

// GetJourneysParams defines parameters for GetJourneys.
type GetJourneysParams struct {
	// From "from" as stop/station ID (e.g. from=8010159 for Halle (Saale) Hbf)
	From *string `form:"from,omitempty" json:"from,omitempty"`

	// FromId "from" as POI (e.g. from.id=991561765&from.latitude=51.48364&from.longitude=11.98084 for Halle+(Saale),+Stadtpark+Halle+(Grünanlagen))
	FromId *string `form:"from.id,omitempty" json:"from.id,omitempty"`

	// FromAddress "from" as an address (e.g. from.latitude=51.25639&from.longitude=7.46685&from.address=Hansestadt+Breckerfeld,+Hansering+3 for Hansestadt Breckerfeld, Hansering 3)
	FromAddress   *string  `form:"from.address,omitempty" json:"from.address,omitempty"`
	FromLatitude  *float32 `form:"from.latitude,omitempty" json:"from.latitude,omitempty"`
	FromLongitude *float32 `form:"from.longitude,omitempty" json:"from.longitude,omitempty"`

	// To "to" as stop/station ID
	To *string `form:"to,omitempty" json:"to,omitempty"`

	// ToId "to" as POI
	ToId *string `form:"to.id,omitempty" json:"to.id,omitempty"`

	// ToAddress "to" as an address
	ToAddress   *string  `form:"to.address,omitempty" json:"to.address,omitempty"`
	ToLatitude  *float32 `form:"to.latitude,omitempty" json:"to.latitude,omitempty"`
	ToLongitude *float32 `form:"to.longitude,omitempty" json:"to.longitude,omitempty"`

	// Departure Compute journeys departing at this date/time. Mutually exclusive with `arrival`. – Default: *now*
	Departure *time.Time `form:"departure,omitempty" json:"departure,omitempty"`

	// Arrival Compute journeys arriving at this date/time. Mutually exclusive with `departure`. – Default: *now*
	Arrival *time.Time `form:"arrival,omitempty" json:"arrival,omitempty"`

	// EarlierThan Compute journeys "before" an `ealierRef`.
	EarlierThan *string `form:"earlierThan,omitempty" json:"earlierThan,omitempty"`

	// LaterThan Compute journeys "after" an `laterRef`.
	LaterThan *string `form:"laterThan,omitempty" json:"laterThan,omitempty"`

	// Results Max. number of journeys.
	Results *int `form:"results,omitempty" json:"results,omitempty"`

	// Stopovers Fetch & parse stopovers on the way?
	Stopovers *bool `form:"stopovers,omitempty" json:"stopovers,omitempty"`

	// Transfers Maximum number of transfers. – Default: *let HAFAS decide*
	Transfers *int `form:"transfers,omitempty" json:"transfers,omitempty"`

	// TransferTime Minimum time in minutes for a single transfer.
	TransferTime *int `form:"transferTime,omitempty" json:"transferTime,omitempty"`

	// Accessibility not supported
	Accessibility *string `form:"accessibility,omitempty" json:"accessibility,omitempty"`

	// Bike Compute only bike-friendly journeys?
	Bike *bool `form:"bike,omitempty" json:"bike,omitempty"`

	// StartWithWalking not supported
	StartWithWalking *bool `form:"startWithWalking,omitempty" json:"startWithWalking,omitempty"`

	// WalkingSpeed not supported
	WalkingSpeed *GetJourneysParamsWalkingSpeed `form:"walkingSpeed,omitempty" json:"walkingSpeed,omitempty"`

	// Tickets Return information about available tickets? only supported for /journeys/{ref}
	Tickets *bool `form:"tickets,omitempty" json:"tickets,omitempty"`

	// Polylines Fetch & parse a shape for each journey leg? only supported for /journeys/{ref}
	Polylines *bool `form:"polylines,omitempty" json:"polylines,omitempty"`

	// SubStops not supported
	SubStops *bool `form:"subStops,omitempty" json:"subStops,omitempty"`

	// Entrances not supported
	Entrances *bool `form:"entrances,omitempty" json:"entrances,omitempty"`

	// Remarks Parse & return hints & warnings?
	Remarks *bool `form:"remarks,omitempty" json:"remarks,omitempty"`

	// ScheduledDays Parse & return dates each journey is valid on?
	ScheduledDays *bool `form:"scheduledDays,omitempty" json:"scheduledDays,omitempty"`

	// Language Language of the results.
	Language *string `form:"language,omitempty" json:"language,omitempty"`

	// LoyaltyCard Type of loyalty card in use. – Default: *none*
	LoyaltyCard *GetJourneysParamsLoyaltyCard `form:"loyaltyCard,omitempty" json:"loyaltyCard,omitempty"`

	// FirstClass Search for first-class options?
	FirstClass *bool `form:"firstClass,omitempty" json:"firstClass,omitempty"`

	// Age Age of traveller – Default: *adult*
	Age *int `form:"age,omitempty" json:"age,omitempty"`

	// Products Filter by profile-specific products (e.g. regional transport only).
	Products *ProfileSpecificProducts `form:"products,omitempty" json:"products,omitempty"`

	// Pretty Pretty-print JSON responses?
	Pretty *bool `form:"pretty,omitempty" json:"pretty,omitempty"`
}

// GetJourneysParamsWalkingSpeed defines parameters for GetJourneys.
type GetJourneysParamsWalkingSpeed string

// GetJourneysParamsLoyaltyCard defines parameters for GetJourneys.
type GetJourneysParamsLoyaltyCard string

// GetJourneysRefParams defines parameters for GetJourneysRef.
type GetJourneysRefParams struct {
	// Stopovers Fetch & parse stopovers on the way?
	Stopovers *bool `form:"stopovers,omitempty" json:"stopovers,omitempty"`

	// Tickets Return information about available tickets? mutually exclusive with polylines
	Tickets *bool `form:"tickets,omitempty" json:"tickets,omitempty"`

	// Polylines Fetch & parse a shape for each journey leg? mutually exclusive with tickets
	Polylines *bool `form:"polylines,omitempty" json:"polylines,omitempty"`

	// SubStops not supported
	SubStops *bool `form:"subStops,omitempty" json:"subStops,omitempty"`

	// Entrances not supported
	Entrances *bool `form:"entrances,omitempty" json:"entrances,omitempty"`

	// Remarks Parse & return hints & warnings?
	Remarks *bool `form:"remarks,omitempty" json:"remarks,omitempty"`

	// ScheduledDays Parse & return dates the journey is valid on?
	ScheduledDays *bool `form:"scheduledDays,omitempty" json:"scheduledDays,omitempty"`

	// Language Language of the results.
	Language *string `form:"language,omitempty" json:"language,omitempty"`

	// Pretty Pretty-print JSON responses?
	Pretty *bool `form:"pretty,omitempty" json:"pretty,omitempty"`
}

// GetLocationsParams defines parameters for GetLocations.
type GetLocationsParams struct {
	// Query The term to search for.
	Query string `form:"query" json:"query"`

	// Fuzzy Find more than exact matches?
	Fuzzy *bool `form:"fuzzy,omitempty" json:"fuzzy,omitempty"`

	// Results How many stations shall be shown?
	Results *int `form:"results,omitempty" json:"results,omitempty"`

	// Stops Show stops/stations?
	Stops *bool `form:"stops,omitempty" json:"stops,omitempty"`

	// Addresses Show addresses?
	Addresses *bool `form:"addresses,omitempty" json:"addresses,omitempty"`

	// Poi Show points of interest?
	Poi *bool `form:"poi,omitempty" json:"poi,omitempty"`

	// LinesOfStops Parse & return lines of each stop/station?
	LinesOfStops *bool `form:"linesOfStops,omitempty" json:"linesOfStops,omitempty"`

	// Language Language of the results.
	Language *string `form:"language,omitempty" json:"language,omitempty"`

	// Pretty Pretty-print JSON responses?
	Pretty *bool `form:"pretty,omitempty" json:"pretty,omitempty"`
}

// GetLocationsNearbyParams defines parameters for GetLocationsNearby.
type GetLocationsNearbyParams struct {
	Location *Location `form:"location,omitempty" json:"location,omitempty"`

	// Results maximum number of results
	Results *int `form:"results,omitempty" json:"results,omitempty"`

	// Distance maximum walking distance in meters – Default: –
	Distance *int `form:"distance,omitempty" json:"distance,omitempty"`

	// Stops Return stops/stations?
	Stops *bool `form:"stops,omitempty" json:"stops,omitempty"`

	// Poi Return points of interest?
	Poi *bool `form:"poi,omitempty" json:"poi,omitempty"`

	// LinesOfStops not supported
	LinesOfStops *bool `form:"linesOfStops,omitempty" json:"linesOfStops,omitempty"`

	// Language Language of the results.
	Language *string `form:"language,omitempty" json:"language,omitempty"`

	// Pretty Pretty-print JSON responses?
	Pretty *bool `form:"pretty,omitempty" json:"pretty,omitempty"`
}

// GetStopsIdParams defines parameters for GetStopsId.
type GetStopsIdParams struct {
	// LinesOfStops Parse & expose lines at each stop/station?
	LinesOfStops *bool `form:"linesOfStops,omitempty" json:"linesOfStops,omitempty"`

	// Language Language of the results.
	Language *string `form:"language,omitempty" json:"language,omitempty"`

	// Pretty Pretty-print JSON responses?
	Pretty *bool `form:"pretty,omitempty" json:"pretty,omitempty"`
}

// GetStopsIdArrivalsParams defines parameters for GetStopsIdArrivals.
type GetStopsIdArrivalsParams struct {
	// When Date & time to get departures for. – Default: *now*
	When *time.Time `form:"when,omitempty" json:"when,omitempty"`

	// Direction not supported
	Direction *string `form:"direction,omitempty" json:"direction,omitempty"`

	// Duration Show departures for how many minutes?
	Duration *int `form:"duration,omitempty" json:"duration,omitempty"`

	// Results Max. number of departures. – Default: *whatever HAFAS wants*
	Results *int `form:"results,omitempty" json:"results,omitempty"`

	// LinesOfStops not supported
	LinesOfStops *bool `form:"linesOfStops,omitempty" json:"linesOfStops,omitempty"`

	// Remarks Parse & return hints & warnings?
	Remarks *bool `form:"remarks,omitempty" json:"remarks,omitempty"`

	// Language Language of the results.
	Language *string `form:"language,omitempty" json:"language,omitempty"`

	// Products Filter by profile-specific products (e.g. regional transport only).
	Products *ProfileSpecificProducts `form:"products,omitempty" json:"products,omitempty"`

	// Pretty Pretty-print JSON responses?
	Pretty *bool `form:"pretty,omitempty" json:"pretty,omitempty"`
}

// GetStopsIdDeparturesParams defines parameters for GetStopsIdDepartures.
type GetStopsIdDeparturesParams struct {
	// When Date & time to get departures for. – Default: *now*
	When *time.Time `form:"when,omitempty" json:"when,omitempty"`

	// Direction not supported
	Direction *string `form:"direction,omitempty" json:"direction,omitempty"`

	// Duration Show departures for how many minutes?
	Duration *int `form:"duration,omitempty" json:"duration,omitempty"`

	// Results Max. number of departures. – Default: *whatever HAFAS wants
	Results *int `form:"results,omitempty" json:"results,omitempty"`

	// LinesOfStops not supported
	LinesOfStops *bool `form:"linesOfStops,omitempty" json:"linesOfStops,omitempty"`

	// Remarks Parse & return hints & warnings?
	Remarks *bool `form:"remarks,omitempty" json:"remarks,omitempty"`

	// Language Language of the results.
	Language *string `form:"language,omitempty" json:"language,omitempty"`

	// Products Filter by profile-specific products (e.g. regional transport only).
	Products *ProfileSpecificProducts `form:"products,omitempty" json:"products,omitempty"`

	// Pretty Pretty-print JSON responses?
	Pretty *bool `form:"pretty,omitempty" json:"pretty,omitempty"`
}

// GetTripsIdParams defines parameters for GetTripsId.
type GetTripsIdParams struct {
	// Stopovers Fetch & parse stopovers on the way?
	Stopovers *bool `form:"stopovers,omitempty" json:"stopovers,omitempty"`

	// Remarks Parse & return hints & warnings?
	Remarks *bool `form:"remarks,omitempty" json:"remarks,omitempty"`

	// Polyline Fetch & parse the geographic shape of the trip? (does not work for RIS trip ids from boards of db profile)
	Polyline *bool `form:"polyline,omitempty" json:"polyline,omitempty"`

	// Language Language of the results.
	Language *string `form:"language,omitempty" json:"language,omitempty"`

	// Pretty Pretty-print JSON responses?
	Pretty *bool `form:"pretty,omitempty" json:"pretty,omitempty"`
}

// AsLocation returns the union data inside the Alternative_Destination as a Location
func (t Alternative_Destination) AsLocation() (Location, error) {
	var body Location
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLocation overwrites any union data inside the Alternative_Destination as the provided Location
func (t *Alternative_Destination) FromLocation(v Location) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLocation performs a merge with any union data inside the Alternative_Destination, using the provided Location
func (t *Alternative_Destination) MergeLocation(v Location) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStation returns the union data inside the Alternative_Destination as a Station
func (t Alternative_Destination) AsStation() (Station, error) {
	var body Station
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStation overwrites any union data inside the Alternative_Destination as the provided Station
func (t *Alternative_Destination) FromStation(v Station) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStation performs a merge with any union data inside the Alternative_Destination, using the provided Station
func (t *Alternative_Destination) MergeStation(v Station) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStop returns the union data inside the Alternative_Destination as a Stop
func (t Alternative_Destination) AsStop() (Stop, error) {
	var body Stop
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStop overwrites any union data inside the Alternative_Destination as the provided Stop
func (t *Alternative_Destination) FromStop(v Stop) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStop performs a merge with any union data inside the Alternative_Destination, using the provided Stop
func (t *Alternative_Destination) MergeStop(v Stop) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Alternative_Destination) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Alternative_Destination) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsLocation returns the union data inside the Alternative_Origin as a Location
func (t Alternative_Origin) AsLocation() (Location, error) {
	var body Location
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLocation overwrites any union data inside the Alternative_Origin as the provided Location
func (t *Alternative_Origin) FromLocation(v Location) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLocation performs a merge with any union data inside the Alternative_Origin, using the provided Location
func (t *Alternative_Origin) MergeLocation(v Location) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStation returns the union data inside the Alternative_Origin as a Station
func (t Alternative_Origin) AsStation() (Station, error) {
	var body Station
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStation overwrites any union data inside the Alternative_Origin as the provided Station
func (t *Alternative_Origin) FromStation(v Station) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStation performs a merge with any union data inside the Alternative_Origin, using the provided Station
func (t *Alternative_Origin) MergeStation(v Station) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStop returns the union data inside the Alternative_Origin as a Stop
func (t Alternative_Origin) AsStop() (Stop, error) {
	var body Stop
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStop overwrites any union data inside the Alternative_Origin as the provided Stop
func (t *Alternative_Origin) FromStop(v Stop) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStop performs a merge with any union data inside the Alternative_Origin, using the provided Stop
func (t *Alternative_Origin) MergeStop(v Stop) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Alternative_Origin) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Alternative_Origin) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsHint returns the union data inside the Alternative_Remarks_Item as a Hint
func (t Alternative_Remarks_Item) AsHint() (Hint, error) {
	var body Hint
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromHint overwrites any union data inside the Alternative_Remarks_Item as the provided Hint
func (t *Alternative_Remarks_Item) FromHint(v Hint) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeHint performs a merge with any union data inside the Alternative_Remarks_Item, using the provided Hint
func (t *Alternative_Remarks_Item) MergeHint(v Hint) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStatus returns the union data inside the Alternative_Remarks_Item as a Status
func (t Alternative_Remarks_Item) AsStatus() (Status, error) {
	var body Status
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStatus overwrites any union data inside the Alternative_Remarks_Item as the provided Status
func (t *Alternative_Remarks_Item) FromStatus(v Status) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStatus performs a merge with any union data inside the Alternative_Remarks_Item, using the provided Status
func (t *Alternative_Remarks_Item) MergeStatus(v Status) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsWarning returns the union data inside the Alternative_Remarks_Item as a Warning
func (t Alternative_Remarks_Item) AsWarning() (Warning, error) {
	var body Warning
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWarning overwrites any union data inside the Alternative_Remarks_Item as the provided Warning
func (t *Alternative_Remarks_Item) FromWarning(v Warning) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWarning performs a merge with any union data inside the Alternative_Remarks_Item, using the provided Warning
func (t *Alternative_Remarks_Item) MergeWarning(v Warning) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Alternative_Remarks_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Alternative_Remarks_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStation returns the union data inside the Alternative_Stop as a Station
func (t Alternative_Stop) AsStation() (Station, error) {
	var body Station
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStation overwrites any union data inside the Alternative_Stop as the provided Station
func (t *Alternative_Stop) FromStation(v Station) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStation performs a merge with any union data inside the Alternative_Stop, using the provided Station
func (t *Alternative_Stop) MergeStation(v Station) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStop returns the union data inside the Alternative_Stop as a Stop
func (t Alternative_Stop) AsStop() (Stop, error) {
	var body Stop
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStop overwrites any union data inside the Alternative_Stop as the provided Stop
func (t *Alternative_Stop) FromStop(v Stop) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStop performs a merge with any union data inside the Alternative_Stop, using the provided Stop
func (t *Alternative_Stop) MergeStop(v Stop) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Alternative_Stop) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Alternative_Stop) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsLocation returns the union data inside the Edge_FromLocation as a Location
func (t Edge_FromLocation) AsLocation() (Location, error) {
	var body Location
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLocation overwrites any union data inside the Edge_FromLocation as the provided Location
func (t *Edge_FromLocation) FromLocation(v Location) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLocation performs a merge with any union data inside the Edge_FromLocation, using the provided Location
func (t *Edge_FromLocation) MergeLocation(v Location) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStation returns the union data inside the Edge_FromLocation as a Station
func (t Edge_FromLocation) AsStation() (Station, error) {
	var body Station
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStation overwrites any union data inside the Edge_FromLocation as the provided Station
func (t *Edge_FromLocation) FromStation(v Station) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStation performs a merge with any union data inside the Edge_FromLocation, using the provided Station
func (t *Edge_FromLocation) MergeStation(v Station) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStop returns the union data inside the Edge_FromLocation as a Stop
func (t Edge_FromLocation) AsStop() (Stop, error) {
	var body Stop
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStop overwrites any union data inside the Edge_FromLocation as the provided Stop
func (t *Edge_FromLocation) FromStop(v Stop) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStop performs a merge with any union data inside the Edge_FromLocation, using the provided Stop
func (t *Edge_FromLocation) MergeStop(v Stop) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Edge_FromLocation) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Edge_FromLocation) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsLocation returns the union data inside the Edge_ToLocation as a Location
func (t Edge_ToLocation) AsLocation() (Location, error) {
	var body Location
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLocation overwrites any union data inside the Edge_ToLocation as the provided Location
func (t *Edge_ToLocation) FromLocation(v Location) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLocation performs a merge with any union data inside the Edge_ToLocation, using the provided Location
func (t *Edge_ToLocation) MergeLocation(v Location) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStation returns the union data inside the Edge_ToLocation as a Station
func (t Edge_ToLocation) AsStation() (Station, error) {
	var body Station
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStation overwrites any union data inside the Edge_ToLocation as the provided Station
func (t *Edge_ToLocation) FromStation(v Station) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStation performs a merge with any union data inside the Edge_ToLocation, using the provided Station
func (t *Edge_ToLocation) MergeStation(v Station) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStop returns the union data inside the Edge_ToLocation as a Stop
func (t Edge_ToLocation) AsStop() (Stop, error) {
	var body Stop
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStop overwrites any union data inside the Edge_ToLocation as the provided Stop
func (t *Edge_ToLocation) FromStop(v Stop) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStop performs a merge with any union data inside the Edge_ToLocation, using the provided Stop
func (t *Edge_ToLocation) MergeStop(v Stop) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Edge_ToLocation) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Edge_ToLocation) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsLocation returns the union data inside the Event_FromLocation as a Location
func (t Event_FromLocation) AsLocation() (Location, error) {
	var body Location
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLocation overwrites any union data inside the Event_FromLocation as the provided Location
func (t *Event_FromLocation) FromLocation(v Location) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLocation performs a merge with any union data inside the Event_FromLocation, using the provided Location
func (t *Event_FromLocation) MergeLocation(v Location) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStation returns the union data inside the Event_FromLocation as a Station
func (t Event_FromLocation) AsStation() (Station, error) {
	var body Station
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStation overwrites any union data inside the Event_FromLocation as the provided Station
func (t *Event_FromLocation) FromStation(v Station) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStation performs a merge with any union data inside the Event_FromLocation, using the provided Station
func (t *Event_FromLocation) MergeStation(v Station) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStop returns the union data inside the Event_FromLocation as a Stop
func (t Event_FromLocation) AsStop() (Stop, error) {
	var body Stop
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStop overwrites any union data inside the Event_FromLocation as the provided Stop
func (t *Event_FromLocation) FromStop(v Stop) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStop performs a merge with any union data inside the Event_FromLocation, using the provided Stop
func (t *Event_FromLocation) MergeStop(v Stop) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Event_FromLocation) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Event_FromLocation) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsLocation returns the union data inside the Event_ToLocation as a Location
func (t Event_ToLocation) AsLocation() (Location, error) {
	var body Location
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLocation overwrites any union data inside the Event_ToLocation as the provided Location
func (t *Event_ToLocation) FromLocation(v Location) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLocation performs a merge with any union data inside the Event_ToLocation, using the provided Location
func (t *Event_ToLocation) MergeLocation(v Location) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStation returns the union data inside the Event_ToLocation as a Station
func (t Event_ToLocation) AsStation() (Station, error) {
	var body Station
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStation overwrites any union data inside the Event_ToLocation as the provided Station
func (t *Event_ToLocation) FromStation(v Station) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStation performs a merge with any union data inside the Event_ToLocation, using the provided Station
func (t *Event_ToLocation) MergeStation(v Station) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStop returns the union data inside the Event_ToLocation as a Stop
func (t Event_ToLocation) AsStop() (Stop, error) {
	var body Stop
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStop overwrites any union data inside the Event_ToLocation as the provided Stop
func (t *Event_ToLocation) FromStop(v Stop) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStop performs a merge with any union data inside the Event_ToLocation, using the provided Stop
func (t *Event_ToLocation) MergeStop(v Stop) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Event_ToLocation) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Event_ToLocation) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsFeatureProperties0 returns the union data inside the Feature_Properties as a FeatureProperties0
func (t Feature_Properties) AsFeatureProperties0() (FeatureProperties0, error) {
	var body FeatureProperties0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFeatureProperties0 overwrites any union data inside the Feature_Properties as the provided FeatureProperties0
func (t *Feature_Properties) FromFeatureProperties0(v FeatureProperties0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFeatureProperties0 performs a merge with any union data inside the Feature_Properties, using the provided FeatureProperties0
func (t *Feature_Properties) MergeFeatureProperties0(v FeatureProperties0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsLocation returns the union data inside the Feature_Properties as a Location
func (t Feature_Properties) AsLocation() (Location, error) {
	var body Location
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLocation overwrites any union data inside the Feature_Properties as the provided Location
func (t *Feature_Properties) FromLocation(v Location) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLocation performs a merge with any union data inside the Feature_Properties, using the provided Location
func (t *Feature_Properties) MergeLocation(v Location) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStation returns the union data inside the Feature_Properties as a Station
func (t Feature_Properties) AsStation() (Station, error) {
	var body Station
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStation overwrites any union data inside the Feature_Properties as the provided Station
func (t *Feature_Properties) FromStation(v Station) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStation performs a merge with any union data inside the Feature_Properties, using the provided Station
func (t *Feature_Properties) MergeStation(v Station) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStop returns the union data inside the Feature_Properties as a Stop
func (t Feature_Properties) AsStop() (Stop, error) {
	var body Stop
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStop overwrites any union data inside the Feature_Properties as the provided Stop
func (t *Feature_Properties) FromStop(v Stop) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStop performs a merge with any union data inside the Feature_Properties, using the provided Stop
func (t *Feature_Properties) MergeStop(v Stop) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Feature_Properties) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Feature_Properties) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsLocation returns the union data inside the Frame_Destination as a Location
func (t Frame_Destination) AsLocation() (Location, error) {
	var body Location
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLocation overwrites any union data inside the Frame_Destination as the provided Location
func (t *Frame_Destination) FromLocation(v Location) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLocation performs a merge with any union data inside the Frame_Destination, using the provided Location
func (t *Frame_Destination) MergeLocation(v Location) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStop returns the union data inside the Frame_Destination as a Stop
func (t Frame_Destination) AsStop() (Stop, error) {
	var body Stop
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStop overwrites any union data inside the Frame_Destination as the provided Stop
func (t *Frame_Destination) FromStop(v Stop) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStop performs a merge with any union data inside the Frame_Destination, using the provided Stop
func (t *Frame_Destination) MergeStop(v Stop) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Frame_Destination) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Frame_Destination) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsLocation returns the union data inside the Frame_Origin as a Location
func (t Frame_Origin) AsLocation() (Location, error) {
	var body Location
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLocation overwrites any union data inside the Frame_Origin as the provided Location
func (t *Frame_Origin) FromLocation(v Location) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLocation performs a merge with any union data inside the Frame_Origin, using the provided Location
func (t *Frame_Origin) MergeLocation(v Location) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStop returns the union data inside the Frame_Origin as a Stop
func (t Frame_Origin) AsStop() (Stop, error) {
	var body Stop
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStop overwrites any union data inside the Frame_Origin as the provided Stop
func (t *Frame_Origin) FromStop(v Stop) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStop performs a merge with any union data inside the Frame_Origin, using the provided Stop
func (t *Frame_Origin) MergeStop(v Stop) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Frame_Origin) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Frame_Origin) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsHint returns the union data inside the Journey_Remarks_Item as a Hint
func (t Journey_Remarks_Item) AsHint() (Hint, error) {
	var body Hint
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromHint overwrites any union data inside the Journey_Remarks_Item as the provided Hint
func (t *Journey_Remarks_Item) FromHint(v Hint) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeHint performs a merge with any union data inside the Journey_Remarks_Item, using the provided Hint
func (t *Journey_Remarks_Item) MergeHint(v Hint) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStatus returns the union data inside the Journey_Remarks_Item as a Status
func (t Journey_Remarks_Item) AsStatus() (Status, error) {
	var body Status
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStatus overwrites any union data inside the Journey_Remarks_Item as the provided Status
func (t *Journey_Remarks_Item) FromStatus(v Status) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStatus performs a merge with any union data inside the Journey_Remarks_Item, using the provided Status
func (t *Journey_Remarks_Item) MergeStatus(v Status) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsWarning returns the union data inside the Journey_Remarks_Item as a Warning
func (t Journey_Remarks_Item) AsWarning() (Warning, error) {
	var body Warning
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWarning overwrites any union data inside the Journey_Remarks_Item as the provided Warning
func (t *Journey_Remarks_Item) FromWarning(v Warning) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWarning performs a merge with any union data inside the Journey_Remarks_Item, using the provided Warning
func (t *Journey_Remarks_Item) MergeWarning(v Warning) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Journey_Remarks_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Journey_Remarks_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsLocation returns the union data inside the Leg_Destination as a Location
func (t Leg_Destination) AsLocation() (Location, error) {
	var body Location
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLocation overwrites any union data inside the Leg_Destination as the provided Location
func (t *Leg_Destination) FromLocation(v Location) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLocation performs a merge with any union data inside the Leg_Destination, using the provided Location
func (t *Leg_Destination) MergeLocation(v Location) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStation returns the union data inside the Leg_Destination as a Station
func (t Leg_Destination) AsStation() (Station, error) {
	var body Station
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStation overwrites any union data inside the Leg_Destination as the provided Station
func (t *Leg_Destination) FromStation(v Station) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStation performs a merge with any union data inside the Leg_Destination, using the provided Station
func (t *Leg_Destination) MergeStation(v Station) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStop returns the union data inside the Leg_Destination as a Stop
func (t Leg_Destination) AsStop() (Stop, error) {
	var body Stop
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStop overwrites any union data inside the Leg_Destination as the provided Stop
func (t *Leg_Destination) FromStop(v Stop) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStop performs a merge with any union data inside the Leg_Destination, using the provided Stop
func (t *Leg_Destination) MergeStop(v Stop) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Leg_Destination) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Leg_Destination) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsLocation returns the union data inside the Leg_Origin as a Location
func (t Leg_Origin) AsLocation() (Location, error) {
	var body Location
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLocation overwrites any union data inside the Leg_Origin as the provided Location
func (t *Leg_Origin) FromLocation(v Location) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLocation performs a merge with any union data inside the Leg_Origin, using the provided Location
func (t *Leg_Origin) MergeLocation(v Location) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStation returns the union data inside the Leg_Origin as a Station
func (t Leg_Origin) AsStation() (Station, error) {
	var body Station
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStation overwrites any union data inside the Leg_Origin as the provided Station
func (t *Leg_Origin) FromStation(v Station) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStation performs a merge with any union data inside the Leg_Origin, using the provided Station
func (t *Leg_Origin) MergeStation(v Station) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStop returns the union data inside the Leg_Origin as a Stop
func (t Leg_Origin) AsStop() (Stop, error) {
	var body Stop
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStop overwrites any union data inside the Leg_Origin as the provided Stop
func (t *Leg_Origin) FromStop(v Stop) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStop performs a merge with any union data inside the Leg_Origin, using the provided Stop
func (t *Leg_Origin) MergeStop(v Stop) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Leg_Origin) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Leg_Origin) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsHint returns the union data inside the Leg_Remarks_Item as a Hint
func (t Leg_Remarks_Item) AsHint() (Hint, error) {
	var body Hint
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromHint overwrites any union data inside the Leg_Remarks_Item as the provided Hint
func (t *Leg_Remarks_Item) FromHint(v Hint) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeHint performs a merge with any union data inside the Leg_Remarks_Item, using the provided Hint
func (t *Leg_Remarks_Item) MergeHint(v Hint) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStatus returns the union data inside the Leg_Remarks_Item as a Status
func (t Leg_Remarks_Item) AsStatus() (Status, error) {
	var body Status
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStatus overwrites any union data inside the Leg_Remarks_Item as the provided Status
func (t *Leg_Remarks_Item) FromStatus(v Status) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStatus performs a merge with any union data inside the Leg_Remarks_Item, using the provided Status
func (t *Leg_Remarks_Item) MergeStatus(v Status) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsWarning returns the union data inside the Leg_Remarks_Item as a Warning
func (t Leg_Remarks_Item) AsWarning() (Warning, error) {
	var body Warning
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWarning overwrites any union data inside the Leg_Remarks_Item as the provided Warning
func (t *Leg_Remarks_Item) FromWarning(v Warning) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWarning performs a merge with any union data inside the Leg_Remarks_Item, using the provided Warning
func (t *Leg_Remarks_Item) MergeWarning(v Warning) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Leg_Remarks_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Leg_Remarks_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsLocation returns the union data inside the Station_Stops_Item as a Location
func (t Station_Stops_Item) AsLocation() (Location, error) {
	var body Location
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLocation overwrites any union data inside the Station_Stops_Item as the provided Location
func (t *Station_Stops_Item) FromLocation(v Location) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLocation performs a merge with any union data inside the Station_Stops_Item, using the provided Location
func (t *Station_Stops_Item) MergeLocation(v Location) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStation returns the union data inside the Station_Stops_Item as a Station
func (t Station_Stops_Item) AsStation() (Station, error) {
	var body Station
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStation overwrites any union data inside the Station_Stops_Item as the provided Station
func (t *Station_Stops_Item) FromStation(v Station) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStation performs a merge with any union data inside the Station_Stops_Item, using the provided Station
func (t *Station_Stops_Item) MergeStation(v Station) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStop returns the union data inside the Station_Stops_Item as a Stop
func (t Station_Stops_Item) AsStop() (Stop, error) {
	var body Stop
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStop overwrites any union data inside the Station_Stops_Item as the provided Stop
func (t *Station_Stops_Item) FromStop(v Stop) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStop performs a merge with any union data inside the Station_Stops_Item, using the provided Stop
func (t *Station_Stops_Item) MergeStop(v Stop) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Station_Stops_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Station_Stops_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsHint returns the union data inside the StopOver_Remarks_Item as a Hint
func (t StopOver_Remarks_Item) AsHint() (Hint, error) {
	var body Hint
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromHint overwrites any union data inside the StopOver_Remarks_Item as the provided Hint
func (t *StopOver_Remarks_Item) FromHint(v Hint) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeHint performs a merge with any union data inside the StopOver_Remarks_Item, using the provided Hint
func (t *StopOver_Remarks_Item) MergeHint(v Hint) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStatus returns the union data inside the StopOver_Remarks_Item as a Status
func (t StopOver_Remarks_Item) AsStatus() (Status, error) {
	var body Status
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStatus overwrites any union data inside the StopOver_Remarks_Item as the provided Status
func (t *StopOver_Remarks_Item) FromStatus(v Status) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStatus performs a merge with any union data inside the StopOver_Remarks_Item, using the provided Status
func (t *StopOver_Remarks_Item) MergeStatus(v Status) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsWarning returns the union data inside the StopOver_Remarks_Item as a Warning
func (t StopOver_Remarks_Item) AsWarning() (Warning, error) {
	var body Warning
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWarning overwrites any union data inside the StopOver_Remarks_Item as the provided Warning
func (t *StopOver_Remarks_Item) FromWarning(v Warning) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWarning performs a merge with any union data inside the StopOver_Remarks_Item, using the provided Warning
func (t *StopOver_Remarks_Item) MergeWarning(v Warning) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StopOver_Remarks_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StopOver_Remarks_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsStation returns the union data inside the StopOver_Stop as a Station
func (t StopOver_Stop) AsStation() (Station, error) {
	var body Station
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStation overwrites any union data inside the StopOver_Stop as the provided Station
func (t *StopOver_Stop) FromStation(v Station) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStation performs a merge with any union data inside the StopOver_Stop, using the provided Station
func (t *StopOver_Stop) MergeStation(v Station) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStop returns the union data inside the StopOver_Stop as a Stop
func (t StopOver_Stop) AsStop() (Stop, error) {
	var body Stop
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStop overwrites any union data inside the StopOver_Stop as the provided Stop
func (t *StopOver_Stop) FromStop(v Stop) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStop performs a merge with any union data inside the StopOver_Stop, using the provided Stop
func (t *StopOver_Stop) MergeStop(v Stop) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t StopOver_Stop) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *StopOver_Stop) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsLocation returns the union data inside the Trip_Destination as a Location
func (t Trip_Destination) AsLocation() (Location, error) {
	var body Location
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLocation overwrites any union data inside the Trip_Destination as the provided Location
func (t *Trip_Destination) FromLocation(v Location) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLocation performs a merge with any union data inside the Trip_Destination, using the provided Location
func (t *Trip_Destination) MergeLocation(v Location) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStation returns the union data inside the Trip_Destination as a Station
func (t Trip_Destination) AsStation() (Station, error) {
	var body Station
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStation overwrites any union data inside the Trip_Destination as the provided Station
func (t *Trip_Destination) FromStation(v Station) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStation performs a merge with any union data inside the Trip_Destination, using the provided Station
func (t *Trip_Destination) MergeStation(v Station) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStop returns the union data inside the Trip_Destination as a Stop
func (t Trip_Destination) AsStop() (Stop, error) {
	var body Stop
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStop overwrites any union data inside the Trip_Destination as the provided Stop
func (t *Trip_Destination) FromStop(v Stop) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStop performs a merge with any union data inside the Trip_Destination, using the provided Stop
func (t *Trip_Destination) MergeStop(v Stop) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Trip_Destination) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Trip_Destination) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsLocation returns the union data inside the Trip_Origin as a Location
func (t Trip_Origin) AsLocation() (Location, error) {
	var body Location
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLocation overwrites any union data inside the Trip_Origin as the provided Location
func (t *Trip_Origin) FromLocation(v Location) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLocation performs a merge with any union data inside the Trip_Origin, using the provided Location
func (t *Trip_Origin) MergeLocation(v Location) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStation returns the union data inside the Trip_Origin as a Station
func (t Trip_Origin) AsStation() (Station, error) {
	var body Station
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStation overwrites any union data inside the Trip_Origin as the provided Station
func (t *Trip_Origin) FromStation(v Station) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStation performs a merge with any union data inside the Trip_Origin, using the provided Station
func (t *Trip_Origin) MergeStation(v Station) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStop returns the union data inside the Trip_Origin as a Stop
func (t Trip_Origin) AsStop() (Stop, error) {
	var body Stop
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStop overwrites any union data inside the Trip_Origin as the provided Stop
func (t *Trip_Origin) FromStop(v Stop) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStop performs a merge with any union data inside the Trip_Origin, using the provided Stop
func (t *Trip_Origin) MergeStop(v Stop) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Trip_Origin) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Trip_Origin) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsHint returns the union data inside the Trip_Remarks_Item as a Hint
func (t Trip_Remarks_Item) AsHint() (Hint, error) {
	var body Hint
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromHint overwrites any union data inside the Trip_Remarks_Item as the provided Hint
func (t *Trip_Remarks_Item) FromHint(v Hint) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeHint performs a merge with any union data inside the Trip_Remarks_Item, using the provided Hint
func (t *Trip_Remarks_Item) MergeHint(v Hint) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStatus returns the union data inside the Trip_Remarks_Item as a Status
func (t Trip_Remarks_Item) AsStatus() (Status, error) {
	var body Status
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStatus overwrites any union data inside the Trip_Remarks_Item as the provided Status
func (t *Trip_Remarks_Item) FromStatus(v Status) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStatus performs a merge with any union data inside the Trip_Remarks_Item, using the provided Status
func (t *Trip_Remarks_Item) MergeStatus(v Status) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsWarning returns the union data inside the Trip_Remarks_Item as a Warning
func (t Trip_Remarks_Item) AsWarning() (Warning, error) {
	var body Warning
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromWarning overwrites any union data inside the Trip_Remarks_Item as the provided Warning
func (t *Trip_Remarks_Item) FromWarning(v Warning) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeWarning performs a merge with any union data inside the Trip_Remarks_Item, using the provided Warning
func (t *Trip_Remarks_Item) MergeWarning(v Warning) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Trip_Remarks_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Trip_Remarks_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsLocation returns the union data inside the Warning_FromStops_Item as a Location
func (t Warning_FromStops_Item) AsLocation() (Location, error) {
	var body Location
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLocation overwrites any union data inside the Warning_FromStops_Item as the provided Location
func (t *Warning_FromStops_Item) FromLocation(v Location) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLocation performs a merge with any union data inside the Warning_FromStops_Item, using the provided Location
func (t *Warning_FromStops_Item) MergeLocation(v Location) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStation returns the union data inside the Warning_FromStops_Item as a Station
func (t Warning_FromStops_Item) AsStation() (Station, error) {
	var body Station
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStation overwrites any union data inside the Warning_FromStops_Item as the provided Station
func (t *Warning_FromStops_Item) FromStation(v Station) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStation performs a merge with any union data inside the Warning_FromStops_Item, using the provided Station
func (t *Warning_FromStops_Item) MergeStation(v Station) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStop returns the union data inside the Warning_FromStops_Item as a Stop
func (t Warning_FromStops_Item) AsStop() (Stop, error) {
	var body Stop
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStop overwrites any union data inside the Warning_FromStops_Item as the provided Stop
func (t *Warning_FromStops_Item) FromStop(v Stop) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStop performs a merge with any union data inside the Warning_FromStops_Item, using the provided Stop
func (t *Warning_FromStops_Item) MergeStop(v Stop) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Warning_FromStops_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Warning_FromStops_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsLocation returns the union data inside the Warning_ToStops_Item as a Location
func (t Warning_ToStops_Item) AsLocation() (Location, error) {
	var body Location
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromLocation overwrites any union data inside the Warning_ToStops_Item as the provided Location
func (t *Warning_ToStops_Item) FromLocation(v Location) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeLocation performs a merge with any union data inside the Warning_ToStops_Item, using the provided Location
func (t *Warning_ToStops_Item) MergeLocation(v Location) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStation returns the union data inside the Warning_ToStops_Item as a Station
func (t Warning_ToStops_Item) AsStation() (Station, error) {
	var body Station
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStation overwrites any union data inside the Warning_ToStops_Item as the provided Station
func (t *Warning_ToStops_Item) FromStation(v Station) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStation performs a merge with any union data inside the Warning_ToStops_Item, using the provided Station
func (t *Warning_ToStops_Item) MergeStation(v Station) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStop returns the union data inside the Warning_ToStops_Item as a Stop
func (t Warning_ToStops_Item) AsStop() (Stop, error) {
	var body Stop
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStop overwrites any union data inside the Warning_ToStops_Item as the provided Stop
func (t *Warning_ToStops_Item) FromStop(v Stop) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStop performs a merge with any union data inside the Warning_ToStops_Item, using the provided Stop
func (t *Warning_ToStops_Item) MergeStop(v Stop) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Warning_ToStops_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Warning_ToStops_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetJourneys request
	GetJourneys(ctx context.Context, params *GetJourneysParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetJourneysRef request
	GetJourneysRef(ctx context.Context, ref string, params *GetJourneysRefParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLocations request
	GetLocations(ctx context.Context, params *GetLocationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetLocationsNearby request
	GetLocationsNearby(ctx context.Context, params *GetLocationsNearbyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStopsId request
	GetStopsId(ctx context.Context, id string, params *GetStopsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStopsIdArrivals request
	GetStopsIdArrivals(ctx context.Context, id string, params *GetStopsIdArrivalsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStopsIdDepartures request
	GetStopsIdDepartures(ctx context.Context, id string, params *GetStopsIdDeparturesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTripsId request
	GetTripsId(ctx context.Context, id string, params *GetTripsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetJourneys(ctx context.Context, params *GetJourneysParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetJourneysRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetJourneysRef(ctx context.Context, ref string, params *GetJourneysRefParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetJourneysRefRequest(c.Server, ref, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLocations(ctx context.Context, params *GetLocationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLocationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetLocationsNearby(ctx context.Context, params *GetLocationsNearbyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetLocationsNearbyRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStopsId(ctx context.Context, id string, params *GetStopsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStopsIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStopsIdArrivals(ctx context.Context, id string, params *GetStopsIdArrivalsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStopsIdArrivalsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStopsIdDepartures(ctx context.Context, id string, params *GetStopsIdDeparturesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStopsIdDeparturesRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTripsId(ctx context.Context, id string, params *GetTripsIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTripsIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetJourneysRequest generates requests for GetJourneys
func NewGetJourneysRequest(server string, params *GetJourneysParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/journeys")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.From != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, *params.From); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FromId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from.id", runtime.ParamLocationQuery, *params.FromId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FromAddress != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from.address", runtime.ParamLocationQuery, *params.FromAddress); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FromLatitude != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from.latitude", runtime.ParamLocationQuery, *params.FromLatitude); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FromLongitude != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from.longitude", runtime.ParamLocationQuery, *params.FromLongitude); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.To != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, *params.To); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ToId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to.id", runtime.ParamLocationQuery, *params.ToId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ToAddress != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to.address", runtime.ParamLocationQuery, *params.ToAddress); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ToLatitude != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to.latitude", runtime.ParamLocationQuery, *params.ToLatitude); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ToLongitude != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to.longitude", runtime.ParamLocationQuery, *params.ToLongitude); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Departure != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "departure", runtime.ParamLocationQuery, *params.Departure); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Arrival != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "arrival", runtime.ParamLocationQuery, *params.Arrival); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.EarlierThan != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "earlierThan", runtime.ParamLocationQuery, *params.EarlierThan); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LaterThan != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "laterThan", runtime.ParamLocationQuery, *params.LaterThan); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Results != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "results", runtime.ParamLocationQuery, *params.Results); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Stopovers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stopovers", runtime.ParamLocationQuery, *params.Stopovers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Transfers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transfers", runtime.ParamLocationQuery, *params.Transfers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TransferTime != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "transferTime", runtime.ParamLocationQuery, *params.TransferTime); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Accessibility != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "accessibility", runtime.ParamLocationQuery, *params.Accessibility); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Bike != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "bike", runtime.ParamLocationQuery, *params.Bike); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.StartWithWalking != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startWithWalking", runtime.ParamLocationQuery, *params.StartWithWalking); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.WalkingSpeed != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "walkingSpeed", runtime.ParamLocationQuery, *params.WalkingSpeed); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tickets != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tickets", runtime.ParamLocationQuery, *params.Tickets); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Polylines != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "polylines", runtime.ParamLocationQuery, *params.Polylines); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SubStops != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subStops", runtime.ParamLocationQuery, *params.SubStops); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Entrances != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "entrances", runtime.ParamLocationQuery, *params.Entrances); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Remarks != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "remarks", runtime.ParamLocationQuery, *params.Remarks); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ScheduledDays != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scheduledDays", runtime.ParamLocationQuery, *params.ScheduledDays); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LoyaltyCard != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "loyaltyCard", runtime.ParamLocationQuery, *params.LoyaltyCard); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FirstClass != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "firstClass", runtime.ParamLocationQuery, *params.FirstClass); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Age != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "age", runtime.ParamLocationQuery, *params.Age); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Products != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "products", runtime.ParamLocationQuery, *params.Products); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Pretty != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pretty", runtime.ParamLocationQuery, *params.Pretty); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetJourneysRefRequest generates requests for GetJourneysRef
func NewGetJourneysRefRequest(server string, ref string, params *GetJourneysRefParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "ref", runtime.ParamLocationPath, ref)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/journeys/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Stopovers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stopovers", runtime.ParamLocationQuery, *params.Stopovers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tickets != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tickets", runtime.ParamLocationQuery, *params.Tickets); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Polylines != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "polylines", runtime.ParamLocationQuery, *params.Polylines); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SubStops != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "subStops", runtime.ParamLocationQuery, *params.SubStops); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Entrances != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "entrances", runtime.ParamLocationQuery, *params.Entrances); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Remarks != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "remarks", runtime.ParamLocationQuery, *params.Remarks); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ScheduledDays != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "scheduledDays", runtime.ParamLocationQuery, *params.ScheduledDays); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Pretty != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pretty", runtime.ParamLocationQuery, *params.Pretty); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLocationsRequest generates requests for GetLocations
func NewGetLocationsRequest(server string, params *GetLocationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/locations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "query", runtime.ParamLocationQuery, params.Query); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Fuzzy != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "fuzzy", runtime.ParamLocationQuery, *params.Fuzzy); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Results != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "results", runtime.ParamLocationQuery, *params.Results); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Stops != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stops", runtime.ParamLocationQuery, *params.Stops); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Addresses != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "addresses", runtime.ParamLocationQuery, *params.Addresses); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Poi != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "poi", runtime.ParamLocationQuery, *params.Poi); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinesOfStops != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linesOfStops", runtime.ParamLocationQuery, *params.LinesOfStops); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Pretty != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pretty", runtime.ParamLocationQuery, *params.Pretty); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetLocationsNearbyRequest generates requests for GetLocationsNearby
func NewGetLocationsNearbyRequest(server string, params *GetLocationsNearbyParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/locations/nearby")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Location != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "location", runtime.ParamLocationQuery, *params.Location); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Results != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "results", runtime.ParamLocationQuery, *params.Results); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Distance != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "distance", runtime.ParamLocationQuery, *params.Distance); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Stops != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stops", runtime.ParamLocationQuery, *params.Stops); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Poi != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "poi", runtime.ParamLocationQuery, *params.Poi); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinesOfStops != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linesOfStops", runtime.ParamLocationQuery, *params.LinesOfStops); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Pretty != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pretty", runtime.ParamLocationQuery, *params.Pretty); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStopsIdRequest generates requests for GetStopsId
func NewGetStopsIdRequest(server string, id string, params *GetStopsIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stops/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.LinesOfStops != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linesOfStops", runtime.ParamLocationQuery, *params.LinesOfStops); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Pretty != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pretty", runtime.ParamLocationQuery, *params.Pretty); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStopsIdArrivalsRequest generates requests for GetStopsIdArrivals
func NewGetStopsIdArrivalsRequest(server string, id string, params *GetStopsIdArrivalsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stops/%s/arrivals", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.When != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "when", runtime.ParamLocationQuery, *params.When); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Direction != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "direction", runtime.ParamLocationQuery, *params.Direction); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Duration != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "duration", runtime.ParamLocationQuery, *params.Duration); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Results != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "results", runtime.ParamLocationQuery, *params.Results); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinesOfStops != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linesOfStops", runtime.ParamLocationQuery, *params.LinesOfStops); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Remarks != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "remarks", runtime.ParamLocationQuery, *params.Remarks); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Products != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "products", runtime.ParamLocationQuery, *params.Products); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Pretty != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pretty", runtime.ParamLocationQuery, *params.Pretty); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStopsIdDeparturesRequest generates requests for GetStopsIdDepartures
func NewGetStopsIdDeparturesRequest(server string, id string, params *GetStopsIdDeparturesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stops/%s/departures", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.When != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "when", runtime.ParamLocationQuery, *params.When); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Direction != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "direction", runtime.ParamLocationQuery, *params.Direction); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Duration != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "duration", runtime.ParamLocationQuery, *params.Duration); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Results != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "results", runtime.ParamLocationQuery, *params.Results); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinesOfStops != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linesOfStops", runtime.ParamLocationQuery, *params.LinesOfStops); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Remarks != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "remarks", runtime.ParamLocationQuery, *params.Remarks); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Products != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "products", runtime.ParamLocationQuery, *params.Products); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Pretty != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pretty", runtime.ParamLocationQuery, *params.Pretty); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTripsIdRequest generates requests for GetTripsId
func NewGetTripsIdRequest(server string, id string, params *GetTripsIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/trips/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Stopovers != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "stopovers", runtime.ParamLocationQuery, *params.Stopovers); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Remarks != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "remarks", runtime.ParamLocationQuery, *params.Remarks); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Polyline != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "polyline", runtime.ParamLocationQuery, *params.Polyline); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Language != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "language", runtime.ParamLocationQuery, *params.Language); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Pretty != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "pretty", runtime.ParamLocationQuery, *params.Pretty); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetJourneysWithResponse request
	GetJourneysWithResponse(ctx context.Context, params *GetJourneysParams, reqEditors ...RequestEditorFn) (*GetJourneysResponse, error)

	// GetJourneysRefWithResponse request
	GetJourneysRefWithResponse(ctx context.Context, ref string, params *GetJourneysRefParams, reqEditors ...RequestEditorFn) (*GetJourneysRefResponse, error)

	// GetLocationsWithResponse request
	GetLocationsWithResponse(ctx context.Context, params *GetLocationsParams, reqEditors ...RequestEditorFn) (*GetLocationsResponse, error)

	// GetLocationsNearbyWithResponse request
	GetLocationsNearbyWithResponse(ctx context.Context, params *GetLocationsNearbyParams, reqEditors ...RequestEditorFn) (*GetLocationsNearbyResponse, error)

	// GetStopsIdWithResponse request
	GetStopsIdWithResponse(ctx context.Context, id string, params *GetStopsIdParams, reqEditors ...RequestEditorFn) (*GetStopsIdResponse, error)

	// GetStopsIdArrivalsWithResponse request
	GetStopsIdArrivalsWithResponse(ctx context.Context, id string, params *GetStopsIdArrivalsParams, reqEditors ...RequestEditorFn) (*GetStopsIdArrivalsResponse, error)

	// GetStopsIdDeparturesWithResponse request
	GetStopsIdDeparturesWithResponse(ctx context.Context, id string, params *GetStopsIdDeparturesParams, reqEditors ...RequestEditorFn) (*GetStopsIdDeparturesResponse, error)

	// GetTripsIdWithResponse request
	GetTripsIdWithResponse(ctx context.Context, id string, params *GetTripsIdParams, reqEditors ...RequestEditorFn) (*GetTripsIdResponse, error)
}

type GetJourneysResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON2XX      *struct {
		EarlierRef            *string   `json:"earlierRef,omitempty"`
		Journeys              []Journey `json:"journeys"`
		LaterRef              *string   `json:"laterRef,omitempty"`
		RealtimeDataUpdatedAt *int      `json:"realtimeDataUpdatedAt,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetJourneysResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetJourneysResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetJourneysRefResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON2XX      *struct {
		// Journey A journey is a computed set of directions to get from A to B at a specific time.
		// It would typically be the result of a route planning algorithm.
		Journey               Journey `json:"journey"`
		RealtimeDataUpdatedAt *int    `json:"realtimeDataUpdatedAt,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetJourneysRefResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetJourneysRefResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLocationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON2XX      *[]GetLocations_2XX_Item
}
type GetLocations_2XX_Item struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r GetLocationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLocationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetLocationsNearbyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON2XX      *[]GetLocationsNearby_2XX_Item
}
type GetLocationsNearby_2XX_Item struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r GetLocationsNearbyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLocationsNearbyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStopsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON2XX      *struct {
		union json.RawMessage
	}
}

// Status returns HTTPResponse.Status
func (r GetStopsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStopsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStopsIdArrivalsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON2XX      *struct {
		Arrivals              []Alternative `json:"arrivals"`
		RealtimeDataUpdatedAt *int          `json:"realtimeDataUpdatedAt,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetStopsIdArrivalsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStopsIdArrivalsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStopsIdDeparturesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON2XX      *struct {
		Departures            []Alternative `json:"departures"`
		RealtimeDataUpdatedAt *int          `json:"realtimeDataUpdatedAt,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetStopsIdDeparturesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStopsIdDeparturesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTripsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON2XX      *struct {
		RealtimeDataUpdatedAt *int `json:"realtimeDataUpdatedAt,omitempty"`

		// Trip Trip – a vehicle stopping at a set of stops at specific times
		Trip Trip `json:"trip"`
	}
}

// Status returns HTTPResponse.Status
func (r GetTripsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTripsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetJourneysWithResponse request returning *GetJourneysResponse
func (c *ClientWithResponses) GetJourneysWithResponse(ctx context.Context, params *GetJourneysParams, reqEditors ...RequestEditorFn) (*GetJourneysResponse, error) {
	rsp, err := c.GetJourneys(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetJourneysResponse(rsp)
}

// GetJourneysRefWithResponse request returning *GetJourneysRefResponse
func (c *ClientWithResponses) GetJourneysRefWithResponse(ctx context.Context, ref string, params *GetJourneysRefParams, reqEditors ...RequestEditorFn) (*GetJourneysRefResponse, error) {
	rsp, err := c.GetJourneysRef(ctx, ref, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetJourneysRefResponse(rsp)
}

// GetLocationsWithResponse request returning *GetLocationsResponse
func (c *ClientWithResponses) GetLocationsWithResponse(ctx context.Context, params *GetLocationsParams, reqEditors ...RequestEditorFn) (*GetLocationsResponse, error) {
	rsp, err := c.GetLocations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLocationsResponse(rsp)
}

// GetLocationsNearbyWithResponse request returning *GetLocationsNearbyResponse
func (c *ClientWithResponses) GetLocationsNearbyWithResponse(ctx context.Context, params *GetLocationsNearbyParams, reqEditors ...RequestEditorFn) (*GetLocationsNearbyResponse, error) {
	rsp, err := c.GetLocationsNearby(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetLocationsNearbyResponse(rsp)
}

// GetStopsIdWithResponse request returning *GetStopsIdResponse
func (c *ClientWithResponses) GetStopsIdWithResponse(ctx context.Context, id string, params *GetStopsIdParams, reqEditors ...RequestEditorFn) (*GetStopsIdResponse, error) {
	rsp, err := c.GetStopsId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStopsIdResponse(rsp)
}

// GetStopsIdArrivalsWithResponse request returning *GetStopsIdArrivalsResponse
func (c *ClientWithResponses) GetStopsIdArrivalsWithResponse(ctx context.Context, id string, params *GetStopsIdArrivalsParams, reqEditors ...RequestEditorFn) (*GetStopsIdArrivalsResponse, error) {
	rsp, err := c.GetStopsIdArrivals(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStopsIdArrivalsResponse(rsp)
}

// GetStopsIdDeparturesWithResponse request returning *GetStopsIdDeparturesResponse
func (c *ClientWithResponses) GetStopsIdDeparturesWithResponse(ctx context.Context, id string, params *GetStopsIdDeparturesParams, reqEditors ...RequestEditorFn) (*GetStopsIdDeparturesResponse, error) {
	rsp, err := c.GetStopsIdDepartures(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStopsIdDeparturesResponse(rsp)
}

// GetTripsIdWithResponse request returning *GetTripsIdResponse
func (c *ClientWithResponses) GetTripsIdWithResponse(ctx context.Context, id string, params *GetTripsIdParams, reqEditors ...RequestEditorFn) (*GetTripsIdResponse, error) {
	rsp, err := c.GetTripsId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTripsIdResponse(rsp)
}

// ParseGetJourneysResponse parses an HTTP response from a GetJourneysWithResponse call
func ParseGetJourneysResponse(rsp *http.Response) (*GetJourneysResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetJourneysResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 2:
		var dest struct {
			EarlierRef            *string   `json:"earlierRef,omitempty"`
			Journeys              []Journey `json:"journeys"`
			LaterRef              *string   `json:"laterRef,omitempty"`
			RealtimeDataUpdatedAt *int      `json:"realtimeDataUpdatedAt,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON2XX = &dest

	}

	return response, nil
}

// ParseGetJourneysRefResponse parses an HTTP response from a GetJourneysRefWithResponse call
func ParseGetJourneysRefResponse(rsp *http.Response) (*GetJourneysRefResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetJourneysRefResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 2:
		var dest struct {
			// Journey A journey is a computed set of directions to get from A to B at a specific time.
			// It would typically be the result of a route planning algorithm.
			Journey               Journey `json:"journey"`
			RealtimeDataUpdatedAt *int    `json:"realtimeDataUpdatedAt,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON2XX = &dest

	}

	return response, nil
}

// ParseGetLocationsResponse parses an HTTP response from a GetLocationsWithResponse call
func ParseGetLocationsResponse(rsp *http.Response) (*GetLocationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLocationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 2:
		var dest []GetLocations_2XX_Item
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON2XX = &dest

	}

	return response, nil
}

// ParseGetLocationsNearbyResponse parses an HTTP response from a GetLocationsNearbyWithResponse call
func ParseGetLocationsNearbyResponse(rsp *http.Response) (*GetLocationsNearbyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetLocationsNearbyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 2:
		var dest []GetLocationsNearby_2XX_Item
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON2XX = &dest

	}

	return response, nil
}

// ParseGetStopsIdResponse parses an HTTP response from a GetStopsIdWithResponse call
func ParseGetStopsIdResponse(rsp *http.Response) (*GetStopsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStopsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 2:
		var dest struct {
			union json.RawMessage
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON2XX = &dest

	}

	return response, nil
}

// ParseGetStopsIdArrivalsResponse parses an HTTP response from a GetStopsIdArrivalsWithResponse call
func ParseGetStopsIdArrivalsResponse(rsp *http.Response) (*GetStopsIdArrivalsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStopsIdArrivalsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 2:
		var dest struct {
			Arrivals              []Alternative `json:"arrivals"`
			RealtimeDataUpdatedAt *int          `json:"realtimeDataUpdatedAt,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON2XX = &dest

	}

	return response, nil
}

// ParseGetStopsIdDeparturesResponse parses an HTTP response from a GetStopsIdDeparturesWithResponse call
func ParseGetStopsIdDeparturesResponse(rsp *http.Response) (*GetStopsIdDeparturesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStopsIdDeparturesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 2:
		var dest struct {
			Departures            []Alternative `json:"departures"`
			RealtimeDataUpdatedAt *int          `json:"realtimeDataUpdatedAt,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON2XX = &dest

	}

	return response, nil
}

// ParseGetTripsIdResponse parses an HTTP response from a GetTripsIdWithResponse call
func ParseGetTripsIdResponse(rsp *http.Response) (*GetTripsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTripsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode/100 == 2:
		var dest struct {
			RealtimeDataUpdatedAt *int `json:"realtimeDataUpdatedAt,omitempty"`

			// Trip Trip – a vehicle stopping at a set of stops at specific times
			Trip Trip `json:"trip"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON2XX = &dest

	}

	return response, nil
}
